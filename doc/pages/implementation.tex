\chapter{Realisierung}
Im diesem Kapitel geht es darum, die in der Design-Phase genannten Änderungen
praktisch umzusetzen. Dazu gehört die einzelnen Schritte und die dabei
aufgetretenen Probleme zu erläutern. Dabei wird zuerst auf die
Benchmark-Werkzeuge und anschließend auf den Anwendungsfall eingegangen.

\section{Benchmark-Werkzeug}

\section{Realisierung des Anwendungsfalls}
Der Anwendungsfall wurde als Django-Projekt umgesetzt. Dazu wurde als Beispiel
ein einfacher Buch-Shop gewählt, bei dem die Benutzer die angebotenen Bücher von
0 bis 5 Sterne bewerten können und die Anwendung daraus einen Top-Liste erstellt.

Derzeit gibt es zwei Benutzergruppen, welche verschiedene Bereiche der Anwendung
benutzen können. Die erste Gruppe ist die Gruppe der Administratoren, welche
Zugriff auf alle Funktionen der Anwendung haben. Die Administratoren können neue
Bücher anlegen, editieren oder löschen. Dies erfolgt über das von Django
bereitgestellte Administrator-Bereich. Der Administrator-Bereich ist eigentlich
die Admin-Anwendung. Ein Django-Anwendung ist eine spezielle Komponente, welche
genau eine Aufgabe erfüllt. Eine einmal entwickelte Anwendung sollte im
Ideal-Fall so konzipiert sein, dass sie in mehreren Django-Projekten zum Einsatz
kommen kann. Ein Django-Projekt besteht dabei zwingen aus mindestens einer
Django-Anwendung. Die Admin-Anwendung erzeugt dabei, für einmal definiert
Modelle, selbständig Oberflächen um die CRUD-Methoden bereitzustellen.

Die zweite Gruppe ist die Gruppe der normalen Benutzer, welche die eigentliche
Bewertung vornehmen können. Diese können aus einer Liste von registrierten
Büchern ein Buch auswählen und die dazugehörige Bewertung vornehmen.

\subsection{Anbindung der NoSql-Systeme}
Wie schon in der Design-Phase erwähnt existiert für Memcached bereits eine
Django-Implementierung und auch die benötigten Client-Bibliotheken. Diese wurden
einfach in die bestehende Anwendung integriert, in dem die benötigten
Konfigurationseinstellungen vorgenommen wurden. Dabei wurde zusätzlich die Hilfe
der Bibliothek django-configurations\footnote{\url{https://pypi.python.org/pypi/django-configurations/2.0}}
benutzt um über einfache Optionsschalter die jeweiligen Cache-Implementierungen
auszutauschen. Die Redis-Implementierung wurde nach dem gleichen Prinzip
übernommen.

Da der Voldemort-Client nicht funktionierte, wurde wie schon beschrieben ein
neuer REST-Client entwickelt. Der Client wird dabei mit den Rest-Endpunkten und
den Node-Ids initialisiert. Danach kann der Anwender die Methoden frei benutzen.
Ein Abmelden, wie bei den anderen Bibliotheken ist hierbei nicht notwendig, da
alle Verbindungen über das HTTP-Protokoll laufen und nicht direkt über Sockets.
Danach wurde der neue Voldemort-Cache implementiert. Dabei wurde die von
Django-Cache-Implementierung für Memcached als Ausgangsbasis genommen, da von
der API her Memcached und Voldemort ähnlich sind im Gegensatz zu Redis.

Bei der Anwendung sind alle Systeme gleich gut benutzbar. Je nach Anwendungsfall
kann man mehr oder weniger Aktionen von Django übernehmen lassen. Der einfachste
Fall ist Django die Speicherung der kompletten Anwendung zu überlassen. Etwas
mehr Kontrolle bekommt man, wenn man die Seiten, welche gespeichert werden
sollen selbst festlegt. Nochmals mehr Kontrolle erlangt man, wenn man nur Teile
einer Seite zwischenspeichert und die volle Kontrolle bekommt man, wenn man die
Zugriffsmethoden direkt verwendet. Diese Entscheidung muss jedoch jeder
Entwickler je nach Situation selber fällen.

\subsection{Probleme und offene Punkte bei der Umsetzung}
Trotz der erfolgreichen Anbindung von Voldemort an Django gibt es noch einige
Probleme, bzw. offene Punkte, welche man in einem weiteren
Implementierungsschritt umsetzen kann.

Das erste Problem ist die REST-API von Voldemort, welche auch noch nicht ganz
ausgereift ist. Dies zeigt sich zum Beispiel im Verhalten mit den Vektor-Uhren
und Versionen. Außerdem kann es manchmal zu unkontrollierten Verhalten beim
Speichern und Löschen kommen. Ein weiterer Punkt ist die Übergabe der
Serverinformationen, welche sich derzeit aus URL und Node-Id für den gesamten
Cluster zusammensetzt. Dies ist nicht wünschenswert, da normalerweise, der
Standard Java-Client und auch der rudimentäre Python-Client mit einem Server
des Clusters zufrieden sind und sich die restlichen Informationen vom Cluster
holen. Die normale REST-API bietet jedoch keine Möglichkeit die Metadaten des
Clusters abzufragen. Um die Metadaten des Clusters zu bekommen, muss erst der
existierende Koordinator-Service gestartet werden, welcher dann auch das
komplette Routing übernimmt.

Die Anwendung verfügt derzeit auch über keine Benutzerregistrierung, dies ist
aber notwendig um zu verhindern, dass jemand einen Artikel mehrfach bewertet.

Derzeit ist die entwickelte Anwendung nicht wie eine typische Django-Anwendung
wiederverwendbar, da die Domäne und das Abstimmungssystem in einer Anwendung sind.
Eine Verbesserung wäre es, wenn man das Abstimmungssystem unabhängig von den
einzelnen Produkten ist. Dazu müsste man die derzeitige Abhängigkeit in der
Tabelle zu den Produkten aufheben und die Information, für welches Produkt
abgestimmt wurde, redundant mit speichern.
