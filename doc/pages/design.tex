\chapter{Design}
In diesem Kapitel geht es darum die einzelnen Benchmark-Werkzeuge zu
vergleichen. Dabei werden die einzelnen Tools analysiert und die Schwachstellen
aufgezeigt. Dazu werden für die einzelnen Schwachstellen Lösungsansätze
präsentiert bezugnehmend auf den derzeitigen Stand der Entwicklung der
jeweiligen Werkzeuge.

Des Weiteren wird der umzusetzende Anwendungsfall beschrieben. Dazu gehört, was
der Anwendungsfall zeigen soll mit einer detaillierten Architekturdarstellung
zur Visualisierung. Dabei werden auch erste getroffene Design-Entscheidungen
erläutert.

\section{Analysephase der Benchmark-Werkzeuge}
Wenn man eine eigene Anwendung entwickelt hat oder eine fremde Anwendung
integrieren möchte stellt sich schnell auch die Frage, ob die Anwendung auch für
die ursprünglich geplanten Bedürfnisse auch geeignet ist. Um diese Frage
beantworten zu können, braucht man erst einmal eine Vorstellung, welche
Grenzwerte, sogenannte Metriken, noch akzeptable sind. Danach kann man sich ein
Test-Setup überlegen, wie man die ausgewählten Metriken misst. Anschließend kann
man die gemessenen Werte mit den geplanten Werten vergleichen, ob die Anwendung
für den geplanten Einsatzzweck geeignet ist.


Dabei will man natürlich möglichst den Messvorgang automatisieren um ihn auch
mit unterschiedlichsten Konfigurationen wiederholen zu können und damit die
verschiedenen Einsatzszenarios zu testen.

\subsection{Stand der Entwicklung}
Redis hat für die Performance-Messung ein eigenes Werkzeug
\enquote{redis-benchmark}. Dieses Werkzeug ist komplett in C geschrieben. Im
Wesentlichen besteht das Werkzeug aus einer Event-Schleife für die Verarbeitung
und einem Schreibprozess auf dem Socket. Dabei wurden viele alt bekannte
Konzepte nochmals durch spezielle Wrapper gekapselt. Der Schreibprozess wurde
ausgelagert in eine neue Bibliothek \enquote{hiredis} und wird jetzt Schritt für
Schritt in den Werkzeugen eingesetzt. Das Werkzeug stellt für alle Methoden,
die Redis bereitstellt einen Test zur Verfügung.

Memcached hat kein eigenes Tool zur Messung der Performance. Erst mit Version
1.2 wird ein solches Tool \enquote{memaslab} existieren. Es gibt jedoch einige
externe Werkzeuge. Diese Werkzeuge bauen jedoch alle auf einer alten Version von
\enquote{redis-benchmark} auf. Das bekannteste Werkzeug ist dabei
\enquote{mc-benchmark}. Die Entwickler haben dabei mehr oder weniger alles
unnötige gelöscht und dann das Werkzeug angepasst. Jedoch benutzt keines der
Werkzeuge die existierende Bibliothek \enquote{libmemcached}, welche extra von
Memcached bereitgestellt wird und zusätzliche Konfiguration Möglichkeiten für
Memcached bietet. Des Weiteren unterstützen die Werkzeuge nicht alle Methoden,
die Memcached bereitstellt.

Voldemort hat ebenfalls wie Redis ein eigenes Performane-Werkzeug
\enquote{voldemort-performance-tool}, welches wie der Rest von Voldemort in Java
geschrieben ist. Das Werkzeug bietet für alle Methoden von Voldemort einen
Test an.

Außerdem gibt es noch eine Reihe anderer Werkzeuge, welche von den großen
Firmen wie Amazon, Google, Yahoo,~\dots{} bereitgestellt werden und teilweise
kostenpflichtig sind. Diese Werkzeuge sind dann aber auch in der Lage mehrere
Systeme abzudecken. Ein Open-Source Tool, welches mit Redis und Memcached
umgehen kann, ist
memtier\footnote{\url{https://github.com/RedisLabs/memtier_benchmark}}.

Aufgrund der wenigen Funktionalität und der nicht Benutzung von geeigneten
Bibliotheken. Soll hier das Memcached-Werkzeug \enquote{mc-benchmark}
umgeschrieben werden, um eine bessere Konfiguration zu ermöglichen und die
fehlenden Methoden zu unterstützen. Dadurch ist es außerdem möglich einen
besseren Bezug zum Benchmark-Werkzeug von Redis herzustellen.

\subsection{Analyse- und Desginprozess}
Bevor überhaupt auch nur eine Zeile Code entwickelt wird, erfolgt immer eine
Analyse- und Design-Phase. Dabei geht es darum die Anforderungen und Bedürfnisse
der Kunden zu erfahren und festzuhalten um damit später in der Design-Phase
bessere Entscheidungen treffen zu können. Dies ist notwendig, damit am Ende auch
das vom Kunden gewünschte Produkt abgeliefert wird. Da dies ein komplexer
Prozess ist, sind verschiedene Modelle und Methoden entwickelt worden, um diesen
Prozess zu begleiten.

Zum einen gibt es die schwergewichtigen Prozessmodelle wie zum Beispiel
\enquote{Wasserfall}. Auf der anderen Seite gibt es auch leichtgewichtige
Prozesse wie \enquote{Extrem Programming}. Daneben gibt es noch die Modelle,
die sich genau zwischen den beiden Seiten befinden. Allerdings muss man dabei
beachten, dass dies nur Modelle sind und keine konkreten Arbeitsweisen, sondern
jedes Modell muss an die jeweilige Umgebung angepasst werden. Die
schwergewichtigen Modelle legen dabei ihren Fokus auf Organisation und
Dokumentation und die leichtgewichtig Modelle legen ihren Fokus mehr auf der
Implementierung des Projektes. Egal für welches Modell man sich am Ende auch
entscheidet, kann man die Anforderung des Kunden nicht mit einem oder wenigen
Terminen vollständig erfassen, da meistens die Kunden zu Beginn des Projektes
selbst noch keine Vorstellung von der benötigten Funktionalität haben, sondern
diese erst entwickeln müssen. Die leichtgewichtig Modelle haben hierbei einen
Vorteil, da sie besser mit dynamischen Änderungswünschen des Kunden umgehen
können als die schwergewichtigen Modelle.

\subsection{Anforderungen des Benchmark-Werkzeugs}
Das umgeschriebene Programm \enquote{mc-benchmark} muss dieselbe Funktionalität
erfüllen, wie das Original. Ein Punkt ist dabei, dass die Tests konfigurierbar
sein müssen, um zum Beispiel die Serveradresse des Servers zu ändern, gegen den
die Tests gefahren werden. Der andere Punkt ist, dass die beiden bisherigen
Methoden \enquote{get} und \enquote{set} auch weiterhin unterstützt werden. Es
kann jedoch im Laufe der Entwicklung zu Änderungen kommen, wenn man auf
\enquote{libmemcached} statt \enquote{hiredis} benutzt wird.

Allerdings gibt es noch eine Reihe zusätzlicher Anforderungen. Dazu gehört,
dass die fehlenden Methoden vom Werkzeug mit abgedeckt werden sollen, wie
\enquote{add}, \enquote{replace}, \enquote{append}, \enquote{prepand},
\enquote{delete}, \enquote{incr/decr},~\dots{] . Diese Anforderung ist einfach
umzusetzen, da man auf die vorhandenen Tests zugreifen und diese ggf. anpassen
kann.
